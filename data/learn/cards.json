{
  "lessons": [
    {
      "id": "variables-basics",
      "title": "Variables in JavaScript",
      "day": 1,
      "category": "Fundamentals",
      "difficulty": "beginner",
      "estimatedTime": "10 min",
      "description": "Learn how to declare and use variables in JavaScript with var, let, and const.",
      "content": "## Variable Declaration Types\n\n### **const** - Constant Declaration (Use by Default)\n- **Block-scoped**: Only available within curly brace blocks\n- **Cannot be reassigned**: Value binding is immutable\n- **Must be initialized**: Cannot declare without assigning value\n- **Object contents changeable**: Objects and arrays can be modified\n- **Prevents accidents**: Catches reassignment errors early\n- **Better performance**: JavaScript engines can optimize\n\n### **let** - Modern Variable (When Reassignment Needed)\n- **Block-scoped**: Same scoping rules as const\n- **Cannot be redeclared**: Prevents variable name conflicts\n- **Must be declared before use**: No hoisting behavior\n- **Temporal dead zone**: Error if accessed before declaration\n- **Use for**: Counters, flags, values that change\n\n### **var** - Legacy Declaration (Avoid!)\n- **Function-scoped**: Available throughout entire function\n- **Can be redeclared**: Dangerous overwrites possible\n- **Hoisted**: Can be used before declaration (undefined)\n- **No block scope**: Leaks out of if/for blocks\n- **Global pollution**: Creates properties on window object\n- **Memory leaks**: Can cause closure-related issues\n\n### **Scoping Rules**\n- **Global scope**: Variables declared outside functions\n- **Function scope**: Variables available within function\n- **Block scope**: Variables within curly braces (let/const only)\n- **Module scope**: Variables within ES6 modules\n\n### **Modern Best Practices**\n- **Default to const**: Use unless reassignment needed\n- **Use let sparingly**: Only when value must change\n- **Never use var**: Causes too many problems\n- **Descriptive names**: Make code self-documenting\n- **Initialize when possible**: Avoid undefined states",
      "contentDetails": "## Variable Declaration Types\n\n### 1. **let** - Block Scoped Variable\n- Modern way to declare variables\n- Block-scoped (only available within `{}` blocks)\n- Cannot be redeclared in same scope\n- Must be declared before use\n\n### 2. **const** - Constant Declaration\n- Block-scoped like `let`\n- Cannot be reassigned after declaration\n- Must be initialized when declared\n- Preferred for values that won't change\n\n### 3. **var** - Legacy Declaration\n- Function-scoped (available throughout entire function)\n- Can be redeclared and reassigned\n- Hoisted to top of function\n- **Avoid using in modern JavaScript**\n\n## Best Practices\n- Use `const` by default\n- Use `let` when you need to reassign\n- Never use `var` in modern code\n- Choose descriptive variable names",
      "codeExample": "// Variable declarations\nlet name = 'John';\nconst age = 25;\nvar city = 'New York';\n\n// Block scoping with let and const\nif (true) {\n  let blockScoped = 'only available here';\n  const alsoBlockScoped = 'same here';\n}\n\n// Function scoping with var\nfunction example() {\n  var functionScoped = 'available throughout function';\n}",
      "keyPoints": [
        "let and const are block-scoped",
        "var is function-scoped and should be avoided",
        "const cannot be reassigned",
        "Always prefer const, then let"
      ],
      "quiz": {
        "question": "Which keyword creates a block-scoped variable that cannot be reassigned?",
        "options": ["var", "let", "const", "function"],
        "correctAnswer": 2,
        "explanation": "const creates a block-scoped variable that cannot be reassigned after declaration."
      },
      "tags": ["variables", "scope", "declarations", "fundamentals", "interview"],
      "isCompleted": false,
      "isBookmarked": false
    },
    {
      "id": "data-types",
      "title": "JavaScript Data Types",
      "day": 2,
      "category": "Fundamentals",
      "difficulty": "beginner",
      "estimatedTime": "12 min",
      "description": "Understand the different data types available in JavaScript and how to work with them.",
      "content": "## JavaScript Data Types\n\n### **Primitive Types** (7 total)\n- **Number**: Integers, decimals, Infinity, NaN\n- **String**: Text data in quotes or backticks\n- **Boolean**: True or false values\n- **Undefined**: Variables declared but not assigned\n- **Null**: Intentional absence of value\n- **Symbol**: Unique identifiers (ES6+)\n- **BigInt**: Large integers beyond Number limit (ES2020+)\n\n### **Object Type** (Everything else)\n- **Objects**: Key-value pairs for complex data\n- **Arrays**: Ordered lists of values\n- **Functions**: Reusable blocks of code\n- **Dates**: Date and time objects\n- **RegExp**: Regular expression patterns\n- **Maps & Sets**: Advanced data structures\n\n### **Type Checking Methods**\n- **typeof operator**: Returns string representation of type\n- **Array.isArray()**: Specifically checks for arrays\n- **instanceof**: Checks if object is instance of constructor\n\n### **Important Notes**\n- **typeof null**: Returns 'object' (historical bug)\n- **Arrays are objects**: With numeric indices\n- **Functions are objects**: That can be called\n- **Primitives are immutable**: Cannot be changed\n- **Objects are mutable**: Can be modified after creation\n\n### **Type Coercion**\n- **Automatic conversion**: JavaScript converts types automatically\n- **Explicit conversion**: Use Number(), String(), Boolean()\n- **Comparison gotchas**: Use === for strict equality\n- **Truthy/Falsy**: All values have boolean context",
      "contentDetails": "## JavaScript Data Types Overview\n\n### **Primitive Types** (Immutable)\n\n#### 1. **Number**\n- Represents both integers and floating-point numbers\n- Special values: `Infinity`, `-Infinity`, `NaN`\n- Example: `42`, `3.14`, `NaN`\n\n#### 2. **String**\n- Sequence of characters enclosed in quotes\n- Can use single, double quotes, or template literals\n- Example: `'Hello'`, `\"World\"`, `` `Template ${variable}` ``\n\n#### 3. **Boolean**\n- Represents logical values: `true` or `false`\n- Used in conditional statements and logical operations\n\n#### 4. **Undefined**\n- Variable declared but not assigned a value\n- Function with no return statement returns `undefined`\n\n#### 5. **Null**\n- Intentional absence of any object value\n- Represents \"nothing\" or \"empty\"\n\n#### 6. **Symbol** (ES6+)\n- Unique identifier, even with same description\n- Used for object property keys\n\n#### 7. **BigInt** (ES2020+)\n- For integers larger than `Number.MAX_SAFE_INTEGER`\n- Append `n` to number: `123n`\n\n### **Non-Primitive Types** (Mutable)\n\n#### **Object**\n- Collection of key-value pairs\n- Includes arrays, functions, dates, etc.\n- Passed by reference, not by value",
      "codeExample": "// Primitive types\nlet name = 'Alice';        // string\nlet age = 30;              // number\nlet isActive = true;       // boolean\nlet data = null;           // null\nlet notDefined;            // undefined\nlet id = Symbol('id');     // symbol\n\n// Object types\nlet person = {             // object\n  name: 'Bob',\n  age: 25\n};\nlet numbers = [1, 2, 3];   // array (special object)\nlet greet = function() {   // function (special object)\n  return 'Hello!';\n};",
      "keyPoints": [
        "JavaScript has 7 primitive data types",
        "Objects include arrays and functions",
        "typeof operator helps identify types",
        "null is technically an object (JavaScript quirk)"
      ],
      "quiz": {
        "question": "What will typeof null return?",
        "options": ["'null'", "'undefined'", "'object'", "'boolean'"],
        "correctAnswer": 2,
        "explanation": "typeof null returns 'object' due to a historical bug in JavaScript that has been kept for compatibility."
      },
      "tags": ["data-types", "primitives", "objects", "typeof"],
      "isCompleted": false,
      "isBookmarked": false
    },
    {
      "id": "functions-intro",
      "title": "Introduction to Functions",
      "day": 3,
      "category": "Fundamentals",
      "difficulty": "beginner",
      "estimatedTime": "15 min",
      "description": "Learn how to create and use functions to organize and reuse your code effectively.",
      "content": "## JavaScript Functions\n\n### **Function Declaration**\n- **Hoisted**: Can be called before definition in code\n- **Named function**: Creates function with specific name\n- **Function scope**: Available throughout containing scope\n- **Syntax**: function keyword followed by name and parameters\n- **Use when**: Need hoisting or recursive functions\n\n### **Function Expression**\n- **Not hoisted**: Must define before calling\n- **Assigned to variable**: Function stored in variable\n- **Anonymous or named**: Can have optional name\n- **Block scoped**: When using let/const\n- **Use when**: Want to control when function is available\n\n### **Arrow Functions** (ES6+)\n- **Concise syntax**: Shorter way to write functions\n- **Lexical this**: Inherits this from parent scope\n- **No arguments object**: Use rest parameters instead\n- **Cannot be constructors**: No new keyword usage\n- **Implicit return**: Single expressions return automatically\n- **Use for**: Callbacks, array methods, short functions\n\n### **Parameters and Arguments**\n- **Default parameters**: Provide fallback values\n- **Rest parameters**: Collect remaining arguments into array\n- **Destructuring**: Extract values from objects/arrays\n- **Parameter validation**: Check types and values\n\n### **Return Values**\n- **Explicit return**: Use return keyword\n- **Implicit return**: Arrow functions with single expression\n- **No return**: Functions return undefined by default\n- **Multiple values**: Return objects or arrays\n\n### **Function Scope and Closures**\n- **Local variables**: Only accessible within function\n- **Closure**: Inner functions access outer variables\n- **Memory**: Variables persist if referenced by closures\n- **Privacy**: Use closures for private variables\n\n### **Best Practices**\n- **Descriptive names**: Make purpose clear\n- **Single responsibility**: One task per function\n- **Pure functions**: Same input produces same output\n- **Avoid side effects**: Don't modify external state\n- **Keep small**: Easier to test and understand",
      "contentDetails": "## JavaScript Functions Overview\n\n### **Function Declaration**\n- Hoisted (can be called before definition)\n- Named function that can be called anywhere in scope\n- Syntax: `function functionName() { }`\n\n### **Function Expression**\n- Not hoisted (must be defined before use)\n- Function assigned to a variable\n- Syntax: `const functionName = function() { }`\n\n### **Arrow Functions** (ES6+)\n- Concise syntax for function expressions\n- Lexical `this` binding\n- Syntax: `const functionName = () => { }`\n- Single expression: `const add = (a, b) => a + b`\n\n### **Function Parameters**\n\n#### **Default Parameters**\n- Provide fallback values when arguments not passed\n- Example: `function greet(name = 'Guest') { }`\n\n#### **Rest Parameters**\n- Collect multiple arguments into an array\n- Example: `function sum(...numbers) { }`\n\n### **Best Practices**\n- Use descriptive function names\n- Keep functions small and focused\n- Prefer arrow functions for callbacks\n- Use default parameters instead of manual checks",
      "codeExample": "// Function declaration\nfunction greet(name) {\n  return `Hello, ${name}!`;\n}\n\n// Function expression\nconst sayHi = function(name) {\n  return `Hi, ${name}!`;\n};\n\n// Arrow function (ES6)\nconst sayHey = (name) => `Hey, ${name}!`;\n\n// Function with default parameters\nfunction introduce(name = 'Anonymous', age = 0) {\n  return `I'm ${name} and I'm ${age} years old.`;\n}\n\n// Using functions\nconsole.log(greet('Alice'));           // Hello, Alice!\nconsole.log(introduce('Bob', 25));     // I'm Bob and I'm 25 years old.",
      "keyPoints": [
        "Functions can be declared or expressed",
        "Arrow functions have concise syntax",
        "Parameters can have default values",
        "Functions should do one thing well"
      ],
      "quiz": {
        "question": "What's the main difference between function declarations and expressions?",
        "options": [
          "No difference",
          "Declarations are hoisted, expressions are not",
          "Expressions are faster",
          "Declarations can't have parameters"
        ],
        "correctAnswer": 1,
        "explanation": "Function declarations are hoisted (can be called before they're defined), while function expressions are not hoisted."
      },
      "tags": ["functions", "parameters", "arrow-functions", "hoisting", "interview"],
      "isCompleted": false,
      "isBookmarked": false
    },
    {
      "id": "arrays-basics",
      "title": "Working with Arrays",
      "day": 4,
      "category": "Data Structures",
      "difficulty": "beginner",
      "estimatedTime": "18 min",
      "description": "Master JavaScript arrays and their powerful built-in methods for data manipulation.",
      "content": "## JavaScript Arrays\n\n### **Array Creation and Structure**\n- **Literal syntax**: Square brackets with comma-separated values\n- **Mixed types**: Can contain different data types together\n- **Zero-indexed**: First element at position 0, last at length-1\n- **Dynamic size**: Length can change during runtime\n- **Sparse arrays**: Can have gaps with undefined elements\n\n### **Adding and Removing Elements**\n- **push()**: Add one or more elements to end, returns new length\n- **pop()**: Remove and return last element\n- **unshift()**: Add elements to beginning, shifts indices\n- **shift()**: Remove and return first element\n- **splice()**: Add/remove elements at any position\n- **slice()**: Extract portion without modifying original\n\n### **Searching and Finding**\n- **indexOf()**: Find first index of element\n- **lastIndexOf()**: Find last index of element\n- **includes()**: Check if element exists (returns boolean)\n- **find()**: Find first element matching condition\n- **findIndex()**: Find index of first matching element\n\n### **Iteration Methods (Functional Programming)**\n- **forEach()**: Execute function for each element\n- **map()**: Transform elements, return new array\n- **filter()**: Select elements that pass test\n- **reduce()**: Reduce array to single value\n- **some()**: Test if any element passes condition\n- **every()**: Test if all elements pass condition\n\n### **Array Properties and Characteristics**\n- **length property**: Number of elements in array\n- **Arrays are objects**: With numeric string keys\n- **Reference type**: Passed by reference, not value\n- **Mutable**: Contents can be changed after creation\n- **Prototype methods**: Inherited from Array.prototype\n\n### **Modern Array Features**\n- **Destructuring**: Extract values into variables\n- **Spread operator**: Expand array elements\n- **Array.from()**: Create arrays from iterables\n- **Array.of()**: Create arrays from arguments\n- **flat()**: Flatten nested arrays\n- **flatMap()**: Map then flatten in one operation\n\n### **Performance Considerations**\n- **Immutable methods**: map, filter, slice create new arrays\n- **Mutating methods**: push, pop, splice modify original\n- **Large arrays**: Consider performance of operations\n- **Memory usage**: Be aware of array size and references",
      "contentDetails": "## JavaScript Arrays Guide\n\n### **Array Creation**\n- **Literal syntax**: `const arr = [1, 2, 3]`\n- **Constructor**: `const arr = new Array(1, 2, 3)`\n- **Mixed types**: `const mixed = ['text', 42, true, null]`\n\n### **Adding/Removing Elements**\n\n#### **End Operations**\n- **`push()`**: Add elements to end\n- **`pop()`**: Remove last element\n\n#### **Beginning Operations**\n- **`unshift()`**: Add elements to beginning\n- **`shift()`**: Remove first element\n\n#### **Middle Operations**\n- **`splice()`**: Add/remove elements at any position\n- **`slice()`**: Extract portion without modifying original\n\n### **Array Iteration Methods**\n\n#### **`forEach()`**\n- Executes function for each element\n- No return value (undefined)\n- Cannot break out early\n\n#### **`map()`**\n- Creates new array with transformed elements\n- Returns new array of same length\n- Pure function (doesn't modify original)\n\n#### **`filter()`**\n- Creates new array with elements that pass test\n- Returns array (potentially shorter)\n\n#### **`find()` & `findIndex()`**\n- Find first element/index that matches condition\n- Returns single value or -1\n\n### **Array Properties**\n- **`length`**: Number of elements\n- **Zero-indexed**: First element at index 0",
      "codeExample": "// Creating arrays\nconst fruits = ['apple', 'banana', 'orange'];\nconst numbers = [1, 2, 3, 4, 5];\nconst mixed = ['text', 42, true, null];\n\n// Array methods\nfruits.push('grape');           // Add to end: ['apple', 'banana', 'orange', 'grape']\nfruits.pop();                   // Remove from end: ['apple', 'banana', 'orange']\nfruits.unshift('mango');        // Add to beginning: ['mango', 'apple', 'banana', 'orange']\nfruits.shift();                 // Remove from beginning: ['apple', 'banana', 'orange']\n\n// Iteration and transformation\nfruits.forEach(fruit => console.log(fruit));\nconst upperFruits = fruits.map(fruit => fruit.toUpperCase());\nconst longFruits = fruits.filter(fruit => fruit.length > 5);",
      "keyPoints": [
        "Arrays are zero-indexed",
        "push/pop work with the end",
        "unshift/shift work with the beginning",
        "map creates new arrays, forEach just iterates"
      ],
      "quiz": {
        "question": "Which method creates a new array with transformed elements?",
        "options": ["forEach()", "map()", "push()", "pop()"],
        "correctAnswer": 1,
        "explanation": "map() creates a new array with the results of calling a function on every element, while forEach() just iterates without returning anything."
      },
      "tags": ["arrays", "methods", "iteration", "data-structures"],
      "isCompleted": false,
      "isBookmarked": false
    },
    {
      "id": "objects-basics",
      "title": "JavaScript Objects",
      "day": 5,
      "category": "Data Structures",
      "difficulty": "intermediate",
      "estimatedTime": "20 min",
      "description": "Learn how to create and manipulate objects, the fundamental building blocks of JavaScript.",
      "content": "## JavaScript Objects\n\n### **Object Creation Methods**\n- **Object literal**: Curly braces with key-value pairs\n- **Constructor function**: Using new keyword with function\n- **Object.create()**: Create with specific prototype\n- **Class syntax**: Modern ES6 class-based creation\n- **Factory functions**: Functions that return objects\n\n### **Property Access Patterns**\n- **Dot notation**: Direct property access with dot\n- **Bracket notation**: Access with string keys\n- **Dynamic access**: Use variables for property names\n- **Computed properties**: Calculate property names\n- **Optional chaining**: Safe access with question mark\n\n### **Property Management**\n- **Adding properties**: Assign values to new keys\n- **Deleting properties**: Use delete operator\n- **Property existence**: Check with in operator or hasOwnProperty\n- **Property descriptors**: Control writable, enumerable, configurable\n- **Getters and setters**: Computed properties with functions\n\n### **Object Methods and Utilities**\n- **Object.keys()**: Get array of property names\n- **Object.values()**: Get array of property values\n- **Object.entries()**: Get array of key-value pairs\n- **Object.assign()**: Copy properties between objects\n- **Object.freeze()**: Make object immutable\n- **Object.seal()**: Prevent adding/removing properties\n\n### **The this Keyword Context**\n- **Method calls**: this refers to calling object\n- **Function calls**: this is undefined in strict mode\n- **Arrow functions**: Inherit this from enclosing scope\n- **Explicit binding**: Use call, apply, bind methods\n- **Constructor calls**: this refers to new instance\n\n### **Object Characteristics**\n- **Reference type**: Objects passed by reference\n- **Mutable**: Properties can be changed after creation\n- **Dynamic**: Properties can be added/removed at runtime\n- **Prototype chain**: Inherit properties from prototype\n- **Enumerable properties**: Can be iterated with for-in loop\n\n### **Advanced Object Concepts**\n- **Prototypal inheritance**: Objects inherit from other objects\n- **Property shadowing**: Local properties hide inherited ones\n- **Object composition**: Combine multiple objects\n- **Mixins**: Add functionality from multiple sources\n- **Proxy objects**: Intercept and customize operations\n\n### **Common Patterns**\n- **Configuration objects**: Pass multiple parameters\n- **Namespace objects**: Group related functionality\n- **Module pattern**: Encapsulate private data\n- **Observer pattern**: Event-driven object communication",
      "contentDetails": "## JavaScript Objects Fundamentals\n\n### **Object Creation**\n\n#### **Object Literal** (Most Common)\n```javascript\nconst person = {\n  name: 'Alice',\n  age: 30,\n  greet() { return 'Hello!'; }\n};\n```\n\n#### **Constructor Function**\n```javascript\nfunction Person(name, age) {\n  this.name = name;\n  this.age = age;\n}\nconst person = new Person('Alice', 30);\n```\n\n#### **Object.create()**\n```javascript\nconst person = Object.create(null);\nperson.name = 'Alice';\n```\n\n### **Property Access**\n\n#### **Dot Notation**\n- `object.property`\n- Property name must be valid identifier\n- Cannot use variables\n\n#### **Bracket Notation**\n- `object['property']`\n- Can use variables and special characters\n- Dynamic property access\n\n### **Object Methods**\n\n#### **Built-in Methods**\n- **`Object.keys()`**: Get array of property names\n- **`Object.values()`**: Get array of property values\n- **`Object.entries()`**: Get array of [key, value] pairs\n- **`Object.assign()`**: Copy properties between objects\n\n### **The `this` Keyword**\n- Refers to the object that owns the method\n- Context-dependent (changes based on how function is called)\n- Arrow functions don't have their own `this`",
      "codeExample": "// Object literal\nconst person = {\n  name: 'Alice',\n  age: 30,\n  city: 'New York',\n  greet() {\n    return `Hi, I'm ${this.name} from ${this.city}`;\n  }\n};\n\n// Accessing properties\nconsole.log(person.name);           // Dot notation\nconsole.log(person['age']);         // Bracket notation\n\n// Adding/modifying properties\nperson.email = 'alice@email.com';\nperson.age = 31;\n\n// Object destructuring\nconst { name, age } = person;\n\n// Object methods\nconst keys = Object.keys(person);       // ['name', 'age', 'city', 'email', 'greet']\nconst values = Object.values(person);   // Values array\nconst entries = Object.entries(person); // [key, value] pairs",
      "keyPoints": [
        "Objects store key-value pairs",
        "Properties can be accessed with dot or bracket notation",
        "Methods are functions stored as object properties",
        "this keyword refers to the object"
      ],
      "quiz": {
        "question": "What does the 'this' keyword refer to in an object method?",
        "options": [
          "The global object",
          "The function itself",
          "The object that owns the method",
          "undefined"
        ],
        "correctAnswer": 2,
        "explanation": "In an object method, 'this' refers to the object that owns the method, allowing access to other properties and methods."
      },
      "tags": ["objects", "properties", "methods", "this-keyword"],
      "isCompleted": false,
      "isBookmarked": false
    },
    {
      "id": "conditionals",
      "title": "Conditional Statements",
      "day": 6,
      "category": "Control Flow",
      "difficulty": "beginner",
      "estimatedTime": "14 min",
      "description": "Master if/else statements, switch cases, and ternary operators for decision making in code.",
      "content": "## Conditional Statements\n\n### **if/else Statement Structure**\n- **Basic if**: Execute code block when condition is true\n- **if/else**: Handle both true and false scenarios\n- **if/else if/else**: Chain multiple conditions together\n- **Nested conditions**: Place if statements inside other if statements\n- **Block scope**: Variables declared inside blocks are local\n\n### **Condition Evaluation**\n- **Boolean expressions**: Evaluate to true or false\n- **Comparison operators**: Equal, not equal, greater, less than\n- **Strict vs loose equality**: Triple equals vs double equals\n- **Type coercion**: JavaScript converts types for comparison\n- **Short-circuit evaluation**: Logical operators stop early\n\n### **Ternary Operator (Conditional Operator)**\n- **Syntax**: Question mark and colon for inline conditions\n- **Use cases**: Simple conditional assignments\n- **Readability**: Good for short, simple conditions\n- **Nesting**: Can chain multiple ternary operators\n- **Return values**: Always returns one of two values\n\n### **Switch Statement**\n- **Multiple specific values**: Better than long if/else chains\n- **Case matching**: Uses strict equality comparison\n- **Break statements**: Prevent fall-through to next case\n- **Default case**: Handles all unmatched values\n- **Fall-through behavior**: Intentionally omit break for multiple cases\n\n### **Logical Operators**\n- **AND operator**: Both conditions must be true\n- **OR operator**: At least one condition must be true\n- **NOT operator**: Inverts boolean value\n- **Short-circuiting**: Stops evaluation when result is determined\n- **Operator precedence**: NOT, then AND, then OR\n\n### **Truthy and Falsy Values**\n- **Falsy values**: false, 0, empty string, null, undefined, NaN\n- **Truthy values**: Everything else including empty arrays and objects\n- **Boolean context**: How values are evaluated in conditions\n- **Type conversion**: How JavaScript converts to boolean\n- **Common gotchas**: Empty arrays and objects are truthy\n\n### **Best Practices**\n- **Use strict equality**: Triple equals prevents type coercion bugs\n- **Explicit conditions**: Make boolean context clear\n- **Avoid deep nesting**: Use early returns or guard clauses\n- **Consistent formatting**: Make code readable and maintainable\n- **Consider switch**: For multiple specific value comparisons\n\n### **Advanced Conditional Patterns**\n- **Guard clauses**: Early returns to reduce nesting\n- **Nullish coalescing**: Handle null and undefined specifically\n- **Optional chaining**: Safe property access on objects\n- **Conditional assignment**: Set values based on conditions",
      "contentDetails": "## Conditional Statements in JavaScript\n\n### **if/else Statements**\n\n#### **Basic if Statement**\n```javascript\nif (condition) {\n  // Execute if condition is true\n}\n```\n\n#### **if/else**\n```javascript\nif (condition) {\n  // Execute if true\n} else {\n  // Execute if false\n}\n```\n\n#### **if/else if/else**\n```javascript\nif (condition1) {\n  // First condition\n} else if (condition2) {\n  // Second condition\n} else {\n  // Default case\n}\n```\n\n### **Ternary Operator**\n- **Syntax**: `condition ? valueIfTrue : valueIfFalse`\n- **Use case**: Simple conditional assignments\n- **Example**: `const status = age >= 18 ? 'adult' : 'minor';`\n\n### **Switch Statement**\n- **Best for**: Multiple specific value comparisons\n- **Remember**: Use `break` to prevent fall-through\n- **Default**: Handles unmatched cases\n\n```javascript\nswitch (value) {\n  case 'option1':\n    // Handle option1\n    break;\n  case 'option2':\n    // Handle option2\n    break;\n  default:\n    // Default case\n}\n```\n\n### **Logical Operators**\n- **`&&` (AND)**: Both conditions must be true\n- **`||` (OR)**: At least one condition must be true\n- **`!` (NOT)**: Inverts the boolean value\n\n### **Truthy vs Falsy Values**\n- **Falsy**: `false`, `0`, `''`, `null`, `undefined`, `NaN`\n- **Truthy**: Everything else",
      "codeExample": "// if/else statements\nconst age = 18;\n\nif (age >= 18) {\n  console.log('You can vote!');\n} else if (age >= 16) {\n  console.log('You can drive!');\n} else {\n  console.log('You are too young.');\n}\n\n// Ternary operator\nconst status = age >= 18 ? 'adult' : 'minor';\n\n// Switch statement\nconst day = 'Monday';\nswitch (day) {\n  case 'Monday':\n    console.log('Start of work week');\n    break;\n  case 'Friday':\n    console.log('TGIF!');\n    break;\n  default:\n    console.log('Regular day');\n}\n\n// Logical operators\nconst isWeekend = day === 'Saturday' || day === 'Sunday';\nconst canWork = age >= 16 && !isWeekend;",
      "keyPoints": [
        "if/else for complex conditions",
        "Ternary operator for simple conditions",
        "Switch for multiple specific values",
        "Logical operators: && (and), || (or), ! (not)"
      ],
      "quiz": {
        "question": "What will this ternary operator return: true ? 'yes' : 'no'?",
        "options": ["true", "'yes'", "'no'", "undefined"],
        "correctAnswer": 1,
        "explanation": "The ternary operator returns 'yes' because the condition (true) is truthy, so it returns the first value after the ?."
      },
      "tags": ["conditionals", "if-else", "ternary", "switch", "logic"],
      "isCompleted": false,
      "isBookmarked": false
    },
    {
      "id": "loops",
      "title": "Loops and Iteration",
      "day": 7,
      "category": "Control Flow",
      "difficulty": "beginner",
      "estimatedTime": "16 min",
      "description": "Learn different types of loops to repeat code efficiently and iterate over data structures.",
      "content": "## JavaScript Loops and Iteration\n\n### **Traditional Loop Structures**\n- **for loop**: Best for known number of iterations with counter\n- **while loop**: Continue while condition is true, unknown iterations\n- **do...while loop**: Execute at least once, then check condition\n- **Initialization**: Set starting values before loop begins\n- **Condition**: Boolean expression checked each iteration\n- **Update**: Modify variables to eventually end loop\n\n### **Modern Iteration Methods**\n- **for...of loop**: Iterate over values in arrays, strings, sets\n- **for...in loop**: Iterate over enumerable properties in objects\n- **Iterator protocol**: Objects that implement Symbol.iterator\n- **Iterable objects**: Arrays, strings, maps, sets, node lists\n- **Clean syntax**: More readable than traditional for loops\n\n### **Array Iteration Methods (Functional Programming)**\n- **forEach()**: Execute function for each element, no return\n- **map()**: Transform each element, return new array\n- **filter()**: Select elements that pass test, return new array\n- **reduce()**: Reduce array to single value through accumulation\n- **some()**: Test if any element passes condition\n- **every()**: Test if all elements pass condition\n- **find()**: Return first element that passes test\n- **findIndex()**: Return index of first element that passes test\n\n### **Loop Control Statements**\n- **break statement**: Exit loop immediately, continue after loop\n- **continue statement**: Skip current iteration, go to next\n- **return statement**: Exit function containing loop\n- **Label statements**: Break or continue specific nested loops\n- **Error handling**: Use try-catch within loops for safety\n\n### **Performance Considerations**\n- **Traditional for**: Fastest for large datasets and simple operations\n- **for...of**: Good balance of performance and readability\n- **Array methods**: Slower but more functional and readable\n- **Avoid for...in**: For arrays, use for objects only\n- **Cache length**: Store array length in variable for optimization\n\n### **Common Loop Patterns**\n- **Counting loops**: Increment or decrement counters\n- **Collection iteration**: Process each item in collection\n- **Search patterns**: Find specific items or conditions\n- **Accumulation**: Build up results over iterations\n- **Nested loops**: Loops within loops for multi-dimensional data\n\n### **Best Practices**\n- **Choose right loop**: Match loop type to use case\n- **Avoid infinite loops**: Ensure termination condition is reachable\n- **Minimize work**: Keep loop bodies efficient\n- **Use descriptive names**: Make loop variables meaningful\n- **Consider alternatives**: Sometimes recursion or array methods better\n\n### **When to Use Each Loop Type**\n- **Counting operations**: Traditional for loop\n- **Array processing**: for...of or array methods\n- **Object iteration**: for...in loop\n- **Condition-based**: while or do...while\n- **Functional style**: Array methods like map, filter, reduce",
      "contentDetails": "## JavaScript Loops and Iteration\n\n### **Traditional Loops**\n\n#### **for Loop**\n- **Best for**: Known number of iterations\n- **Syntax**: `for (initialization; condition; increment)`\n- **Use case**: Counting, array indexing\n\n```javascript\nfor (let i = 0; i < array.length; i++) {\n  console.log(array[i]);\n}\n```\n\n#### **while Loop**\n- **Best for**: Unknown number of iterations\n- **Condition checked before each iteration\n- **Risk**: Infinite loops if condition never becomes false\n\n```javascript\nwhile (condition) {\n  // Code to execute\n  // Don't forget to update condition!\n}\n```\n\n#### **do...while Loop**\n- **Executes at least once** (condition checked after)\n- **Rarely used** but useful for user input validation\n\n### **Modern Iteration**\n\n#### **for...of Loop** (ES6+)\n- **Best for**: Iterating over array values\n- **Clean syntax**: No index management\n- **Works with**: Arrays, strings, Maps, Sets\n\n```javascript\nfor (const item of array) {\n  console.log(item);\n}\n```\n\n#### **for...in Loop**\n- **Best for**: Iterating over object properties\n- **Returns**: Property names (keys)\n- **Caution**: Also iterates inherited properties\n\n```javascript\nfor (const key in object) {\n  console.log(key, object[key]);\n}\n```\n\n### **Array Methods** (Functional Approach)\n- **`forEach()`**: Execute function for each element\n- **`map()`**: Transform each element, return new array\n- **`filter()`**: Select elements that pass test\n- **`reduce()`**: Reduce array to single value",
      "codeExample": "// for loop\nfor (let i = 0; i < 5; i++) {\n  console.log(`Count: ${i}`);\n}\n\n// while loop\nlet count = 0;\nwhile (count < 3) {\n  console.log(`While count: ${count}`);\n  count++;\n}\n\n// for...of loop (for arrays)\nconst fruits = ['apple', 'banana', 'orange'];\nfor (const fruit of fruits) {\n  console.log(fruit);\n}\n\n// for...in loop (for objects)\nconst person = { name: 'Alice', age: 30 };\nfor (const key in person) {\n  console.log(`${key}: ${person[key]}`);\n}\n\n// Array methods (functional approach)\nfruits.forEach(fruit => console.log(fruit));\nconst numbers = [1, 2, 3, 4, 5];\nconst doubled = numbers.map(n => n * 2);\nconst evens = numbers.filter(n => n % 2 === 0);",
      "keyPoints": [
        "for loop for counted iterations",
        "while loop for condition-based iterations",
        "for...of for array values",
        "for...in for object properties"
      ],
      "quiz": {
        "question": "Which loop is best for iterating over array values?",
        "options": ["for", "while", "for...of", "for...in"],
        "correctAnswer": 2,
        "explanation": "for...of is specifically designed for iterating over array values (and other iterables) in a clean, readable way."
      },
      "tags": ["loops", "iteration", "for", "while", "arrays"],
      "isCompleted": false,
      "isBookmarked": false
    },
    {
      "id": "dom-basics",
      "title": "DOM Manipulation Basics",
      "day": 8,
      "category": "Web Development",
      "difficulty": "intermediate",
      "estimatedTime": "22 min",
      "description": "Learn how to interact with HTML elements using JavaScript to create dynamic web pages.",
      "content": "## DOM Manipulation Fundamentals\n\n### **Understanding the DOM**\n- **Document Object Model**: Tree representation of HTML document\n- **Live structure**: Changes reflect immediately in browser\n- **JavaScript interface**: Programmatic access to HTML elements\n- **Node types**: Elements, text nodes, attributes, comments\n- **Parent-child relationships**: Hierarchical structure navigation\n\n### **Element Selection Methods**\n- **querySelector()**: First element matching CSS selector\n- **querySelectorAll()**: All elements matching selector (NodeList)\n- **getElementById()**: Fastest method for ID-based selection\n- **getElementsByClassName()**: Live HTMLCollection by class name\n- **getElementsByTagName()**: Live HTMLCollection by tag name\n- **CSS selectors**: Use any valid CSS selector syntax\n\n### **Content Manipulation Techniques**\n- **textContent**: Plain text content, safe from XSS attacks\n- **innerHTML**: HTML content, potential security risk\n- **innerText**: Visible text, respects styling and layout\n- **outerHTML**: Element and its content as HTML string\n- **insertAdjacentHTML()**: Insert HTML at specific positions\n\n### **Attribute Management**\n- **setAttribute()**: Set attribute values on elements\n- **getAttribute()**: Retrieve attribute values\n- **removeAttribute()**: Remove attributes from elements\n- **hasAttribute()**: Check if attribute exists\n- **data attributes**: Custom attributes for storing data\n\n### **CSS Class and Style Management**\n- **classList.add()**: Add one or more CSS classes\n- **classList.remove()**: Remove specific CSS classes\n- **classList.toggle()**: Add if absent, remove if present\n- **classList.contains()**: Check if class exists\n- **element.style**: Direct inline style manipulation\n- **getComputedStyle()**: Get final computed styles\n\n### **Element Creation and Insertion**\n- **createElement()**: Create new HTML elements\n- **createTextNode()**: Create text nodes\n- **appendChild()**: Add element as last child\n- **insertBefore()**: Insert element before reference node\n- **prepend()**: Add as first child\n- **append()**: Add as last child (modern method)\n\n### **Element Removal and Replacement**\n- **remove()**: Remove element from DOM\n- **removeChild()**: Remove specific child element\n- **replaceChild()**: Replace one child with another\n- **replaceWith()**: Replace element with new content\n\n### **DOM Navigation**\n- **parentNode**: Access parent element\n- **childNodes**: All child nodes including text\n- **children**: Only element children\n- **firstChild/lastChild**: First and last child nodes\n- **nextSibling/previousSibling**: Adjacent sibling nodes\n\n### **Event Handling Integration**\n- **addEventListener()**: Attach event listeners to elements\n- **removeEventListener()**: Remove specific event listeners\n- **Event delegation**: Handle events on parent elements\n- **Event object**: Access event information and methods\n\n### **Performance Best Practices**\n- **Minimize DOM queries**: Cache element references\n- **Batch DOM changes**: Reduce reflows and repaints\n- **Use document fragments**: For multiple element creation\n- **Avoid innerHTML in loops**: Use createElement instead\n- **Debounce frequent updates**: Limit DOM manipulation frequency",
      "contentDetails": "## DOM Manipulation Guide\n\n### **What is the DOM?**\n- **Document Object Model**: Tree-like representation of HTML\n- **Live representation**: Changes reflect immediately in browser\n- **JavaScript interface**: Allows programmatic manipulation\n\n### **Selecting Elements**\n\n#### **Single Element Selection**\n- **`getElementById()`**: Select by ID (fastest)\n- **`querySelector()`**: Select by CSS selector (most flexible)\n\n#### **Multiple Element Selection**\n- **`getElementsByClassName()`**: Select by class name\n- **`getElementsByTagName()`**: Select by tag name\n- **`querySelectorAll()`**: Select all matching CSS selectors\n\n### **Content Manipulation**\n\n#### **Text Content**\n- **`textContent`**: Plain text only (safe from XSS)\n- **`innerText`**: Respects styling (hidden elements ignored)\n- **`innerHTML`**: HTML content (potential XSS risk)\n\n#### **Attributes**\n- **`getAttribute()`**: Get attribute value\n- **`setAttribute()`**: Set attribute value\n- **`removeAttribute()`**: Remove attribute\n\n### **Style Manipulation**\n\n#### **Inline Styles**\n- **`element.style.property`**: Direct style manipulation\n- **Caution**: Creates inline styles (high specificity)\n\n#### **CSS Classes**\n- **`classList.add()`**: Add CSS class\n- **`classList.remove()`**: Remove CSS class\n- **`classList.toggle()`**: Toggle CSS class\n- **`classList.contains()`**: Check if class exists\n\n### **Creating and Modifying Elements**\n- **`createElement()`**: Create new element\n- **`appendChild()`**: Add child element\n- **`removeChild()`**: Remove child element\n- **`insertBefore()`**: Insert element at specific position\n\n### **Event Handling**\n- **`addEventListener()`**: Attach event listeners\n- **`removeEventListener()`**: Remove event listeners\n- **Event object**: Contains information about the event",
      "codeExample": "// Selecting elements\nconst title = document.getElementById('title');\nconst buttons = document.querySelectorAll('.button');\nconst firstParagraph = document.querySelector('p');\n\n// Changing content\ntitle.textContent = 'New Title';\ntitle.innerHTML = '<strong>Bold Title</strong>';\n\n// Changing styles\ntitle.style.color = 'blue';\ntitle.style.fontSize = '24px';\ntitle.classList.add('highlight');\n\n// Creating new elements\nconst newDiv = document.createElement('div');\nnewDiv.textContent = 'Dynamic content';\nnewDiv.className = 'dynamic';\ndocument.body.appendChild(newDiv);\n\n// Event handling\nconst button = document.querySelector('#myButton');\nbutton.addEventListener('click', function() {\n  alert('Button clicked!');\n});\n\n// Form handling\nconst form = document.querySelector('#myForm');\nform.addEventListener('submit', function(event) {\n  event.preventDefault();\n  const formData = new FormData(form);\n  console.log('Form submitted:', formData.get('username'));\n});",
      "keyPoints": [
        "querySelector/querySelectorAll for selecting elements",
        "textContent vs innerHTML for content",
        "classList for CSS class manipulation",
        "addEventListener for event handling"
      ],
      "quiz": {
        "question": "What's the difference between textContent and innerHTML?",
        "options": [
          "No difference",
          "textContent is faster",
          "innerHTML can contain HTML tags, textContent cannot",
          "textContent is deprecated"
        ],
        "correctAnswer": 2,
        "explanation": "innerHTML can contain and render HTML tags, while textContent treats everything as plain text and is safer from XSS attacks."
      },
      "tags": ["dom", "html", "events", "web-development"],
      "isCompleted": false,
      "isBookmarked": false
    },
    {
      "id": "best-practices",
      "title": "JavaScript Best Practices",
      "day": 11,
      "category": "Fundamentals",
      "difficulty": "intermediate",
      "estimatedTime": "15 min",
      "description": "Learn essential coding practices that make your JavaScript code more readable, maintainable, and efficient. These practices will help you write professional-quality code that follows industry standards.",
      "content": "## JavaScript Best Practices\n\n### **Variable Declaration Standards**\n- **Use const by default**: Prevents accidental reassignment errors\n- **Use let when reassignment needed**: For counters, flags, changing values\n- **Avoid var completely**: Function-scoped and causes hoisting issues\n- **Initialize variables**: Avoid undefined states when possible\n- **Meaningful names**: Make code self-documenting\n\n### **Naming Conventions**\n- **camelCase for variables**: firstName, calculateTotal, userAge\n- **PascalCase for constructors**: UserAccount, DatabaseConnection\n- **UPPER_SNAKE_CASE for constants**: MAX_RETRY_ATTEMPTS, API_BASE_URL\n- **Descriptive names**: getUserData() instead of getData()\n- **Avoid abbreviations**: Use fullName instead of fName\n- **Boolean prefixes**: isActive, hasPermission, canEdit\n\n### **Function Design Principles**\n- **Single responsibility**: Each function should do one thing well\n- **Pure functions**: Same input always produces same output\n- **Limit parameters**: Maximum 3-4 parameters, use objects for more\n- **Return early**: Use guard clauses to reduce nesting\n- **Avoid side effects**: Don't modify external state unexpectedly\n- **Descriptive names**: Function name should explain what it does\n\n### **Error Handling Strategies**\n- **Use try-catch blocks**: Handle errors gracefully\n- **Fail fast principle**: Validate inputs early in functions\n- **Meaningful error messages**: Help with debugging and user experience\n- **Custom error types**: Create specific error classes\n- **Log errors appropriately**: Use console.error for debugging\n- **Don't ignore errors**: Always handle or propagate errors\n\n### **Code Organization and Structure**\n- **Use ES6 modules**: Import and export for code organization\n- **Avoid global variables**: Use module scope or namespaces\n- **Consistent formatting**: Follow established style guides\n- **Group related functionality**: Keep similar code together\n- **Separate concerns**: Keep business logic separate from UI\n- **Use meaningful comments**: Explain why, not what\n\n### **Performance Optimization**\n- **Minimize DOM manipulation**: Cache references and batch changes\n- **Use efficient algorithms**: Choose appropriate data structures\n- **Avoid memory leaks**: Remove event listeners and clear references\n- **Lazy loading**: Load resources only when needed\n- **Debounce expensive operations**: Limit frequency of heavy computations\n\n### **Security Considerations**\n- **Validate all inputs**: Never trust user or external data\n- **Avoid innerHTML with user data**: Prevents XSS attacks\n- **Use strict mode**: Catches common mistakes and unsafe actions\n- **Sanitize data**: Clean user inputs before processing\n- **Use HTTPS**: Secure data transmission\n\n### **Modern JavaScript Features**\n- **Use arrow functions**: For callbacks and short functions\n- **Template literals**: For string interpolation and multiline strings\n- **Destructuring**: Extract values from objects and arrays\n- **Spread operator**: For array and object manipulation\n- **Async/await**: For handling asynchronous operations\n- **Optional chaining**: Safe property access on objects\n\n### **Testing and Debugging**\n- **Write unit tests**: Test individual functions and components\n- **Use meaningful test names**: Describe what is being tested\n- **Debug with console methods**: Use console.log, console.error, console.table\n- **Use browser dev tools**: Leverage debugging features\n- **Code reviews**: Have others review your code for quality",
      "contentDetails": "## JavaScript Best Practices\n\n### **Variable Declarations**\n- **Use `const` by default**: Prevents accidental reassignment\n- **Use `let` when reassignment needed**: Block-scoped and safer than `var`\n- **Avoid `var`**: Function-scoped and can cause hoisting issues\n\n### **Naming Conventions**\n- **Use descriptive names**: `getUserData()` not `getData()`\n- **camelCase for variables/functions**: `firstName`, `calculateTotal()`\n- **PascalCase for constructors/classes**: `UserAccount`, `PaymentProcessor`\n- **UPPER_CASE for constants**: `MAX_RETRY_ATTEMPTS`, `API_BASE_URL`\n\n### **Function Best Practices**\n- **Keep functions small**: One responsibility per function\n- **Use pure functions**: Same input → same output, no side effects\n- **Avoid deep nesting**: Use early returns and guard clauses\n- **Use meaningful parameters**: Avoid too many parameters (max 3-4)\n\n### **Error Handling**\n- **Use try-catch blocks**: Handle errors gracefully\n- **Fail fast**: Validate inputs early\n- **Provide meaningful error messages**: Help debugging\n- **Don't ignore errors**: Always handle or log them\n\n### **Code Organization**\n- **Use modules**: Organize code into reusable modules\n- **Avoid global variables**: Use module scope or namespaces\n- **Group related functionality**: Keep related code together\n- **Use consistent formatting**: Follow a style guide (Prettier, ESLint)\n\n### **Performance Considerations**\n- **Avoid premature optimization**: Write readable code first\n- **Cache DOM queries**: Don't query same element repeatedly\n- **Use event delegation**: For dynamic content\n- **Minimize global scope lookups**: Use local variables\n\n### **Modern JavaScript**\n- **Use ES6+ features**: Arrow functions, destructuring, template literals\n- **Prefer array methods**: `map()`, `filter()`, `reduce()` over loops\n- **Use async/await**: Instead of callback hell\n- **Leverage destructuring**: For cleaner variable assignments",
      "keyPoints": [
        "Use meaningful variable and function names",
        "Keep functions small and focused on single tasks",
        "Handle errors gracefully with try-catch blocks",
        "Use const by default, let when reassignment is needed",
        "Avoid global variables and prefer modules",
        "Comment your code when necessary but prefer self-documenting code"
      ],
      "quiz": {
        "question": "Which is the best practice for variable declarations in modern JavaScript?",
        "options": [
          "Always use var for all variables",
          "Use const by default, let when reassignment is needed",
          "Use let for everything",
          "Mix var, let, and const randomly"
        ],
        "correctAnswer": 1,
        "explanation": "Using const by default and let when reassignment is needed helps prevent accidental reassignments and makes code more predictable."
      },
      "tags": ["best-practices", "clean-code", "fundamentals", "professional"],
      "isCompleted": false,
      "isBookmarked": false
    }
  ]
}
