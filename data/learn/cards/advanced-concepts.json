{
  "cards": [
    {
      "id": "closures-advanced",
      "title": "Closures: JavaScript's Superpower",
      "day": 19,
      "category": "Advanced Concepts",
      "difficulty": "advanced",
      "estimatedTime": "6 min",
      "description": "Master closures - one of JavaScript's most powerful and misunderstood features.",
      "content": "## Closures: JavaScript's Superpower\n\n### **What is a Closure?**\n- **Definition**: Function that accesses variables from outer scope\n- **Persistence**: Outer variables remain alive even after function returns\n- **Memory management**: JavaScript keeps outer scope in memory for closure\n- **Lexical scoping**: Variable access based on where variables are defined\n- **Fundamental concept**: Core to understanding JavaScript's behavior\n\n### **How Closures Work**\n- **Function creation**: Inner function captures outer scope variables\n- **Scope chain**: Inner function maintains reference to outer scope\n- **Variable binding**: Specific variables, not copies, are referenced\n- **Execution context**: Outer context preserved for inner function\n- **Garbage collection**: Outer scope kept alive as long as closure exists\n\n### **Practical Applications**\n- **Data privacy**: Create private variables not accessible from outside\n- **Function factories**: Generate specialized functions with preset behavior\n- **Module pattern**: Encapsulate functionality and expose public API\n- **Event handlers**: Maintain state across event occurrences\n- **Callbacks**: Preserve context when passing functions around\n- **Memoization**: Cache function results using closure scope\n\n### **Data Privacy Pattern**\n- **Private variables**: Variables only accessible through closure methods\n- **Controlled access**: Expose only necessary functionality\n- **State management**: Maintain internal state without global variables\n- **Encapsulation**: Hide implementation details from external code\n- **Security**: Prevent direct manipulation of sensitive data\n\n### **Function Factory Pattern**\n- **Parameterized functions**: Create functions with preset configurations\n- **Reusability**: Generate multiple similar functions efficiently\n- **Customization**: Each generated function has its own closure scope\n- **Performance**: Avoid recreating similar logic repeatedly\n\n### **Common Closure Gotchas**\n- **Loop variable problem**: All closures reference same variable\n- **var vs let**: Different scoping behavior in loops\n- **Memory leaks**: Closures keeping large objects alive\n- **Unexpected references**: Closures capturing more than intended\n- **Performance impact**: Creating many closures can be expensive\n\n### **Memory Considerations**\n- **Scope retention**: Entire outer scope may be kept in memory\n- **Circular references**: Closures referencing DOM elements\n- **Cleanup**: Set closure references to null when done\n- **Large objects**: Be careful about what closures capture\n- **Performance monitoring**: Watch for memory usage patterns\n\n### **Best Practices**\n- **Use judiciously**: Only when you need the closure behavior\n- **Minimize captured scope**: Don't capture unnecessary variables\n- **Clean up references**: Prevent memory leaks in long-running apps\n- **Document intent**: Make closure purpose clear in code\n- **Consider alternatives**: Sometimes classes or modules are better\n- **Test memory usage**: Monitor for leaks in complex applications\n\n### **Modern JavaScript and Closures**\n- **Arrow functions**: Also create closures with lexical this binding\n- **Module systems**: ES6 modules provide alternative to closure modules\n- **Class private fields**: New syntax for private data without closures\n- **WeakMap**: Alternative for associating private data with objects\n- **Debugging tools**: Modern dev tools help identify closure issues",
      "contentDetails": "## JavaScript Closures: The Complete Guide\n\n### **What is a Closure?**\n- **Definition**: Function that accesses variables from its outer scope\n- **Persistence**: Outer variables remain accessible even after outer function returns\n- **Memory**: JavaScript keeps outer scope alive for the closure\n- **Lexical scoping**: Variables are accessible based on where they're defined\n\n### **How Closures Work**\n\n#### **Basic Mechanism**\n```javascript\nfunction outer(x) {\n  // Outer scope variable\n  const outerVar = x;\n  \n  function inner(y) {\n    // Can access outerVar even after outer() finishes\n    return outerVar + y;\n  }\n  \n  return inner; // Return function with closure\n}\n\nconst addTen = outer(10);\nconsole.log(addTen(5)); // 15\n```\n\n### **Practical Applications**\n\n#### **1. Data Privacy**\n- **Private variables**: Not accessible from outside\n- **Controlled access**: Only through provided methods\n- **Encapsulation**: Hide implementation details\n\n```javascript\nfunction createCounter() {\n  let count = 0; // Private variable\n  \n  return {\n    increment: () => ++count,\n    decrement: () => --count,\n    getValue: () => count\n  };\n}\n```\n\n#### **2. Function Factories**\n- **Parameterized functions**: Create specialized functions\n- **Configuration**: Set behavior at creation time\n- **Reusability**: Generate multiple similar functions\n\n```javascript\nfunction createValidator(minLength) {\n  return function(input) {\n    return input.length >= minLength;\n  };\n}\n\nconst validatePassword = createValidator(8);\nconst validateUsername = createValidator(3);\n```\n\n#### **3. Module Pattern**\n- **Namespace**: Avoid global pollution\n- **Public API**: Expose only necessary functions\n- **Private implementation**: Hide internal details\n\n```javascript\nconst myModule = (function() {\n  let privateVar = 0;\n  \n  function privateFunction() {\n    return privateVar * 2;\n  }\n  \n  return {\n    publicMethod: function() {\n      return privateFunction();\n    },\n    setPrivateVar: function(value) {\n      privateVar = value;\n    }\n  };\n})();\n```\n\n### **Common Closure Patterns**\n\n#### **Immediately Invoked Function Expression (IIFE)**\n```javascript\nconst result = (function(x) {\n  const multiplier = 2;\n  return x * multiplier;\n})(5); // 10\n```\n\n#### **Event Handlers with State**\n```javascript\nfunction setupButton(name) {\n  let clickCount = 0;\n  \n  document.getElementById('btn').addEventListener('click', function() {\n    clickCount++;\n    console.log(`${name} clicked ${clickCount} times`);\n  });\n}\n```\n\n### **Common Gotchas**\n\n#### **Loop Variable Problem**\n```javascript\n// Problem: All functions reference same variable\nfor (var i = 0; i < 3; i++) {\n  setTimeout(() => console.log(i), 100); // Prints 3, 3, 3\n}\n\n// Solution 1: Use let (block scope)\nfor (let i = 0; i < 3; i++) {\n  setTimeout(() => console.log(i), 100); // Prints 0, 1, 2\n}\n\n// Solution 2: IIFE to capture value\nfor (var i = 0; i < 3; i++) {\n  (function(index) {\n    setTimeout(() => console.log(index), 100);\n  })(i);\n}\n```\n\n### **Memory Considerations**\n\n#### **Memory Leaks**\n- **Circular references**: Closure references DOM element that references closure\n- **Large objects**: Closure keeps entire scope alive\n- **Solution**: Set references to null when done\n\n#### **Performance**\n- **Creation cost**: Each closure creates new scope\n- **Memory usage**: Outer variables remain in memory\n- **Best practice**: Use closures judiciously\n\n### **Advanced Patterns**\n\n#### **Currying**\n```javascript\nfunction curry(fn) {\n  return function curried(...args) {\n    if (args.length >= fn.length) {\n      return fn.apply(this, args);\n    }\n    return function(...nextArgs) {\n      return curried(...args, ...nextArgs);\n    };\n  };\n}\n```\n\n#### **Memoization**\n```javascript\nfunction memoize(fn) {\n  const cache = new Map();\n  \n  return function(...args) {\n    const key = JSON.stringify(args);\n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n    const result = fn.apply(this, args);\n    cache.set(key, result);\n    return result;\n  };\n}\n```\n\n### **Best Practices**\n- **Use for data privacy**: When you need private variables\n- **Avoid in loops**: Unless you need to capture loop variable\n- **Clean up references**: Prevent memory leaks\n- **Prefer modules**: For larger applications\n- **Document intent**: Make closure purpose clear",
      "codeExample": "// Basic closure example\nfunction outerFunction(x) {\n  // This variable is in the outer scope\n  const outerVariable = x;\n  \n  // Inner function has access to outer variables\n  function innerFunction(y) {\n    console.log(`Outer: ${outerVariable}, Inner: ${y}`);\n    return outerVariable + y;\n  }\n  \n  return innerFunction; // Return the inner function\n}\n\nconst addFive = outerFunction(5);\nconsole.log(addFive(10)); // 15\n// outerFunction has finished, but innerFunction still remembers outerVariable!\n\n// Practical example: Counter with private state\nfunction createCounter(initialValue = 0) {\n  let count = initialValue; // Private variable\n  \n  return {\n    increment: () => ++count,\n    decrement: () => --count,\n    getValue: () => count,\n    reset: () => { count = initialValue; }\n  };\n}\n\nconst counter = createCounter(10);\nconsole.log(counter.getValue()); // 10\nconsole.log(counter.increment()); // 11\nconsole.log(counter.increment()); // 12\nconsole.log(counter.decrement()); // 11\n// console.log(count); // ReferenceError: count is not accessible!\n\n// Function factory pattern\nfunction createMultiplier(multiplier) {\n  return function(number) {\n    return number * multiplier;\n  };\n}\n\nconst double = createMultiplier(2);\nconst triple = createMultiplier(3);\nconst quadruple = createMultiplier(4);\n\nconsole.log(double(5)); // 10\nconsole.log(triple(5)); // 15\nconsole.log(quadruple(5)); // 20\n\n// Module pattern with closures\nconst bankAccount = (function(initialBalance) {\n  let balance = initialBalance;\n  let transactionHistory = [];\n  \n  function addTransaction(type, amount) {\n    transactionHistory.push({\n      type,\n      amount,\n      timestamp: new Date(),\n      balance: balance\n    });\n  }\n  \n  return {\n    deposit(amount) {\n      if (amount > 0) {\n        balance += amount;\n        addTransaction('deposit', amount);\n        return balance;\n      }\n      throw new Error('Deposit amount must be positive');\n    },\n    \n    withdraw(amount) {\n      if (amount > 0 && amount <= balance) {\n        balance -= amount;\n        addTransaction('withdrawal', amount);\n        return balance;\n      }\n      throw new Error('Invalid withdrawal amount');\n    },\n    \n    getBalance() {\n      return balance;\n    },\n    \n    getHistory() {\n      return [...transactionHistory]; // Return copy, not reference\n    }\n  };\n})(1000); // IIFE with initial balance\n\nconsole.log(bankAccount.deposit(500)); // 1500\nconsole.log(bankAccount.withdraw(200)); // 1300\nconsole.log(bankAccount.getHistory());\n// balance and transactionHistory are completely private!\n\n// Common closure gotcha and solution\nconsole.log('--- Closure Gotcha ---');\n\n// Problem: All functions reference the same variable\nconst functions = [];\nfor (var i = 0; i < 3; i++) {\n  functions.push(function() {\n    console.log('var i:', i); // All will print 3!\n  });\n}\n\nfunctions.forEach(fn => fn()); // 3, 3, 3\n\n// Solution 1: Use let instead of var\nconst functionsFixed1 = [];\nfor (let i = 0; i < 3; i++) {\n  functionsFixed1.push(function() {\n    console.log('let i:', i); // Each has its own i\n  });\n}\n\nfunctionsFixed1.forEach(fn => fn()); // 0, 1, 2\n\n// Solution 2: IIFE to create separate scope\nconst functionsFixed2 = [];\nfor (var i = 0; i < 3; i++) {\n  functionsFixed2.push((function(index) {\n    return function() {\n      console.log('IIFE index:', index);\n    };\n  })(i));\n}\n\nfunctionsFixed2.forEach(fn => fn()); // 0, 1, 2",
      "keyPoints": [
        "Closures allow inner functions to access outer scope variables",
        "Variables in closures persist even after outer function returns",
        "Perfect for creating private variables and data encapsulation",
        "Common in module patterns and function factories"
      ],
      "quiz": {
        "question": "What makes a closure in JavaScript?",
        "options": ["A function inside another function", "A function that returns another function", "A function that accesses variables from its outer scope", "A function with private variables"],
        "correctAnswer": 2,
        "explanation": "A closure is formed when a function accesses variables from its outer (enclosing) scope, creating a persistent connection to those variables."
      },
      "tags": ["closures", "scope", "private-variables", "advanced"],
      "isCompleted": false,
      "isBookmarked": false
    },
    {
      "id": "classes-oop",
      "title": "Classes: Object-Oriented Programming in JavaScript",
      "day": 15,
      "category": "Advanced Concepts",
      "difficulty": "intermediate",
      "estimatedTime": "7 min",
      "description": "Master JavaScript classes, inheritance, and modern OOP patterns for clean, maintainable code.",
      "content": "## JavaScript Classes: Modern OOP\n\n### **Class Fundamentals**\n- **ES6 feature**: Cleaner syntax for OOP\n- **Syntactic sugar**: Over prototype-based inheritance\n- **More familiar**: To developers from other languages\n\n### **Basic Structure**\n```javascript\nclass Person {\n  constructor(name, age) {\n    this.name = name;\n    this.age = age;\n  }\n  \n  greet() {\n    return `Hello, I'm ${this.name}`;\n  }\n  \n  static createAdult(name) {\n    return new Person(name, 18);\n  }\n}\n```\n\n### **Key Components**\n- **Constructor**: Initialize object state\n- **Instance methods**: Shared behavior\n- **Static methods**: Class-level utilities\n- **Getters/Setters**: Computed properties\n\n### **Inheritance**\n- **`extends`**: Create subclass\n- **`super()`**: Call parent constructor\n- **Method override**: Redefine parent methods\n\n### **Private Fields** (ES2022)\n- **Syntax**: Prefix with `#`\n- **True privacy**: Not accessible outside class\n- **Example**: `#balance = 0`\n\n### **Best Practices**\n- Use classes for object-oriented designs\n- Prefer composition over inheritance\n- Use private fields for encapsulation",
      "contentDetails": "## JavaScript Classes: Modern OOP\n\n### **Class Fundamentals**\n- **ES6 feature**: Introduced in ECMAScript 2015\n- **Syntactic sugar**: Over prototype-based inheritance\n- **Cleaner syntax**: More familiar to OOP developers\n- **Same functionality**: As constructor functions + prototypes\n\n### **Basic Class Structure**\n\n#### **Class Declaration**\n```javascript\nclass MyClass {\n  constructor(param) {\n    this.property = param;\n  }\n  \n  method() {\n    return this.property;\n  }\n}\n```\n\n#### **Class Expression**\n```javascript\nconst MyClass = class {\n  constructor(param) {\n    this.property = param;\n  }\n};\n```\n\n### **Class Components**\n\n#### **Constructor Method**\n- **Special method**: Called when creating new instance\n- **Initialize properties**: Set up object state\n- **One per class**: Only one constructor allowed\n- **Optional**: If not provided, default empty constructor used\n\n#### **Instance Methods**\n- **Shared behavior**: Available on all instances\n- **Access instance data**: Through `this` keyword\n- **Prototype methods**: Added to class prototype\n\n#### **Static Methods**\n- **Class-level methods**: Called on class, not instances\n- **Utility functions**: Related to class but not specific instance\n- **No `this` access**: To instance properties\n\n```javascript\nclass MathUtils {\n  static add(a, b) {\n    return a + b;\n  }\n  \n  static PI = 3.14159;\n}\n\nconsole.log(MathUtils.add(2, 3)); // 5\nconsole.log(MathUtils.PI); // 3.14159\n```\n\n### **Getters and Setters**\n\n#### **Getter Methods**\n- **Computed properties**: Calculate value when accessed\n- **Read-only access**: No direct property assignment\n- **Syntax**: `get propertyName() { }`\n\n#### **Setter Methods**\n- **Controlled assignment**: Validate before setting\n- **Side effects**: Trigger other actions\n- **Syntax**: `set propertyName(value) { }`\n\n```javascript\nclass Temperature {\n  constructor(celsius) {\n    this._celsius = celsius;\n  }\n  \n  get fahrenheit() {\n    return (this._celsius * 9/5) + 32;\n  }\n  \n  set fahrenheit(value) {\n    this._celsius = (value - 32) * 5/9;\n  }\n}\n```\n\n### **Inheritance with `extends`**\n\n#### **Class Inheritance**\n```javascript\nclass Animal {\n  constructor(name) {\n    this.name = name;\n  }\n  \n  speak() {\n    return `${this.name} makes a sound`;\n  }\n}\n\nclass Dog extends Animal {\n  constructor(name, breed) {\n    super(name); // Call parent constructor\n    this.breed = breed;\n  }\n  \n  speak() {\n    return `${this.name} barks`;\n  }\n}\n```\n\n#### **The `super` Keyword**\n- **Parent constructor**: `super()` calls parent constructor\n- **Parent methods**: `super.methodName()` calls parent method\n- **Must call first**: In child constructor before using `this`\n\n### **Private Fields (ES2022)**\n\n#### **Private Properties**\n- **True privacy**: Not accessible outside class\n- **Syntax**: Prefix with `#`\n- **Compile-time error**: If accessed incorrectly\n\n```javascript\nclass BankAccount {\n  #balance = 0;        // Private field\n  #accountNumber;      // Private field\n  \n  constructor(accountNumber) {\n    this.#accountNumber = accountNumber;\n  }\n  \n  deposit(amount) {\n    this.#balance += amount;\n  }\n  \n  get balance() {\n    return this.#balance;\n  }\n  \n  #validateAmount(amount) {  // Private method\n    return amount > 0;\n  }\n}\n```\n\n### **Class vs Constructor Functions**\n\n#### **Class Syntax**\n```javascript\nclass Person {\n  constructor(name) {\n    this.name = name;\n  }\n  \n  greet() {\n    return `Hello, ${this.name}`;\n  }\n}\n```\n\n#### **Equivalent Constructor Function**\n```javascript\nfunction Person(name) {\n  this.name = name;\n}\n\nPerson.prototype.greet = function() {\n  return `Hello, ${this.name}`;\n};\n```\n\n### **Advanced Patterns**\n\n#### **Abstract Base Classes**\n```javascript\nclass Shape {\n  constructor() {\n    if (this.constructor === Shape) {\n      throw new Error('Cannot instantiate abstract class');\n    }\n  }\n  \n  area() {\n    throw new Error('Must implement area method');\n  }\n}\n```\n\n#### **Mixins**\n```javascript\nconst Flyable = {\n  fly() {\n    return `${this.name} is flying`;\n  }\n};\n\nclass Bird {\n  constructor(name) {\n    this.name = name;\n  }\n}\n\nObject.assign(Bird.prototype, Flyable);\n```\n\n### **Best Practices**\n- **Use classes**: For object-oriented designs\n- **Private fields**: For true encapsulation\n- **Static methods**: For utility functions\n- **Getters/setters**: For computed properties\n- **Inheritance**: When there's clear \"is-a\" relationship\n- **Composition over inheritance**: When possible",
      "codeExample": "// Basic class definition\nclass Person {\n  // Constructor method\n  constructor(name, age) {\n    this.name = name;\n    this.age = age;\n    this._id = Math.random(); // Private-ish property\n  }\n\n  // Instance method\n  greet() {\n    return `Hello, I'm ${this.name} and I'm ${this.age} years old.`;\n  }\n\n  // Getter\n  get info() {\n    return `${this.name} (${this.age})`;\n  }\n\n  // Setter\n  set age(newAge) {\n    if (newAge < 0) {\n      throw new Error('Age cannot be negative');\n    }\n    this._age = newAge;\n  }\n\n  get age() {\n    return this._age;\n  }\n\n  // Static method (belongs to class, not instance)\n  static createAdult(name) {\n    return new Person(name, 18);\n  }\n\n  // Static property\n  static species = 'Homo sapiens';\n}\n\n// Creating instances\nconst alice = new Person('Alice', 25);\nconst bob = Person.createAdult('Bob');\n\nconsole.log(alice.greet()); // \"Hello, I'm Alice and I'm 25 years old.\"\nconsole.log(alice.info);    // \"Alice (25)\"\nconsole.log(Person.species); // \"Homo sapiens\"\n\n// Inheritance with extends\nclass Student extends Person {\n  constructor(name, age, major) {\n    super(name, age); // Call parent constructor\n    this.major = major;\n    this.grades = [];\n  }\n\n  // Override parent method\n  greet() {\n    return `${super.greet()} I'm studying ${this.major}.`;\n  }\n\n  // New method\n  addGrade(grade) {\n    this.grades.push(grade);\n  }\n\n  get gpa() {\n    if (this.grades.length === 0) return 0;\n    return this.grades.reduce((sum, grade) => sum + grade, 0) / this.grades.length;\n  }\n}\n\nconst student = new Student('Charlie', 20, 'Computer Science');\nstudent.addGrade(85);\nstudent.addGrade(92);\nconsole.log(student.greet()); // Includes major\nconsole.log(student.gpa);     // 88.5\n\n// Private fields (ES2022)\nclass BankAccount {\n  #balance = 0;     // Private field\n  #accountNumber;   // Private field\n\n  constructor(accountNumber) {\n    this.#accountNumber = accountNumber;\n  }\n\n  // Public method to access private field\n  deposit(amount) {\n    if (amount > 0) {\n      this.#balance += amount;\n    }\n  }\n\n  withdraw(amount) {\n    if (amount > 0 && amount <= this.#balance) {\n      this.#balance -= amount;\n      return amount;\n    }\n    throw new Error('Insufficient funds');\n  }\n\n  get balance() {\n    return this.#balance;\n  }\n\n  // Private method\n  #validateTransaction(amount) {\n    return amount > 0 && amount <= this.#balance;\n  }\n}\n\nconst account = new BankAccount('12345');\naccount.deposit(1000);\nconsole.log(account.balance); // 1000\n// console.log(account.#balance); // SyntaxError: Private field '#balance' must be declared in an enclosing class",
      "keyPoints": [
        "Classes are syntactic sugar over prototypes",
        "Use super() to call parent class methods/constructor",
        "Private fields (#field) are truly private in modern JS",
        "Static methods/properties belong to the class, not instances"
      ],
      "quiz": {
        "question": "What does the 'super' keyword do in a class?",
        "options": ["Creates a new instance", "Calls parent class methods/constructor", "Makes a method static", "Defines private fields"],
        "correctAnswer": 1,
        "explanation": "The 'super' keyword is used to call methods and constructors from the parent class, enabling proper inheritance in JavaScript classes."
      },
      "tags": ["classes", "oop", "inheritance", "private-fields"],
      "isCompleted": false,
      "isBookmarked": false
    }
  ]
}
