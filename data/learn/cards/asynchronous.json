{
  "cards": [
    {
      "id": "promises-async-await",
      "title": "Promises & Async/Await: Mastering Asynchronous JavaScript",
      "day": 18,
      "category": "Asynchronous",
      "difficulty": "intermediate",
      "estimatedTime": "7 min",
      "description": "Master modern asynchronous programming with Promises and async/await syntax.",
      "content": "## Promises & Async/Await Mastery\n\n### **Understanding Async Programming**\n- **Non-blocking**: Code continues while waiting\n- **Event loop**: JavaScript's async mechanism\n- **Essential for**: API calls, file ops, timers\n\n### **Promise States**\n1. **Pending**: Initial state\n2. **Fulfilled**: Operation completed successfully\n3. **Rejected**: Operation failed\n\n### **Promise Methods**\n- **`.then()`**: Handle success\n- **`.catch()`**: Handle errors\n- **`.finally()`**: Execute regardless of outcome\n\n### **Promise Static Methods**\n- **`Promise.all()`**: Wait for all (fails fast)\n- **`Promise.allSettled()`**: Wait for all (never rejects)\n- **`Promise.race()`**: First to settle wins\n\n### **Async/Await Benefits**\n- **Readable**: Looks like synchronous code\n- **Debuggable**: Better stack traces\n- **Error handling**: Use try/catch blocks\n\n### **Best Practices**\n- Always handle errors with `.catch()` or try/catch\n- Use `Promise.all()` for parallel operations\n- Don't forget `await` in async functions",
      "contentDetails": "## Asynchronous JavaScript Mastery\n\n### **Understanding Asynchronous Programming**\n- **Non-blocking**: Code continues while waiting for operations\n- **Event loop**: JavaScript's mechanism for handling async operations\n- **Single-threaded**: JavaScript runs on one thread but handles async efficiently\n- **Essential for**: API calls, file operations, timers, user interactions\n\n### **Promises Fundamentals**\n\n#### **Promise States**\n1. **Pending**: Initial state, neither fulfilled nor rejected\n2. **Fulfilled**: Operation completed successfully\n3. **Rejected**: Operation failed with an error\n\n#### **Creating Promises**\n```javascript\nconst myPromise = new Promise((resolve, reject) => {\n  // Async operation here\n  if (success) {\n    resolve(result);\n  } else {\n    reject(new Error('Something went wrong'));\n  }\n});\n```\n\n#### **Promise Methods**\n- **`.then()`**: Handle successful resolution\n- **`.catch()`**: Handle rejection/errors\n- **`.finally()`**: Execute regardless of outcome\n\n### **Promise Static Methods**\n\n#### **`Promise.all()`**\n- **Purpose**: Wait for all promises to resolve\n- **Behavior**: Fails fast (rejects if any promise rejects)\n- **Use case**: Parallel operations that all must succeed\n\n#### **`Promise.allSettled()`**\n- **Purpose**: Wait for all promises to settle (resolve or reject)\n- **Behavior**: Never rejects, returns results for all\n- **Use case**: When you want results even if some fail\n\n#### **`Promise.race()`**\n- **Purpose**: First promise to settle wins\n- **Use case**: Timeouts, fastest response\n\n#### **`Promise.any()`**\n- **Purpose**: First promise to resolve wins\n- **Use case**: Fallback mechanisms\n\n### **Async/Await Syntax**\n\n#### **Benefits**\n- **Readable**: Looks like synchronous code\n- **Debuggable**: Better stack traces\n- **Error handling**: Use try/catch blocks\n- **Sequential**: Easy to write sequential async operations\n\n#### **Rules**\n- **`async` functions**: Always return a Promise\n- **`await` keyword**: Only works inside async functions\n- **Error handling**: Use try/catch for await operations\n\n### **Error Handling Patterns**\n\n#### **With Promises**\n```javascript\nfetchData()\n  .then(result => processResult(result))\n  .catch(error => handleError(error))\n  .finally(() => cleanup());\n```\n\n#### **With Async/Await**\n```javascript\ntry {\n  const result = await fetchData();\n  processResult(result);\n} catch (error) {\n  handleError(error);\n} finally {\n  cleanup();\n}\n```\n\n### **Common Patterns**\n\n#### **Sequential Operations**\n```javascript\nconst result1 = await operation1();\nconst result2 = await operation2(result1);\nconst result3 = await operation3(result2);\n```\n\n#### **Parallel Operations**\n```javascript\nconst [result1, result2, result3] = await Promise.all([\n  operation1(),\n  operation2(),\n  operation3()\n]);\n```\n\n### **Best Practices**\n- **Always handle errors**: Use .catch() or try/catch\n- **Avoid callback hell**: Use Promises or async/await\n- **Parallel when possible**: Use Promise.all() for independent operations\n- **Don't forget await**: Common mistake in async functions\n- **Return promises**: From async functions when needed",
      "codeExample": "// Creating and using Promises\nconst fetchUserData = (userId) => {\n  return new Promise((resolve, reject) => {\n    // Simulate API call\n    setTimeout(() => {\n      if (userId > 0) {\n        resolve({ id: userId, name: 'Alice', email: 'alice@example.com' });\n      } else {\n        reject(new Error('Invalid user ID'));\n      }\n    }, 1000);\n  });\n};\n\n// Using Promises with .then()\nfetchUserData(1)\n  .then(user => {\n    console.log('User data:', user);\n    return fetchUserData(2); // Chain another promise\n  })\n  .then(user2 => {\n    console.log('Second user:', user2);\n  })\n  .catch(error => {\n    console.error('Error:', error.message);\n  })\n  .finally(() => {\n    console.log('Promise chain completed');\n  });\n\n// Modern async/await syntax (much cleaner!)\nasync function getUserData(userId) {\n  try {\n    const user = await fetchUserData(userId);\n    console.log('User data:', user);\n    \n    // Sequential async operations\n    const user2 = await fetchUserData(userId + 1);\n    console.log('Second user:', user2);\n    \n    return { user, user2 };\n  } catch (error) {\n    console.error('Error:', error.message);\n    throw error; // Re-throw if needed\n  }\n}\n\n// Parallel async operations\nasync function getMultipleUsers() {\n  try {\n    // All requests start simultaneously\n    const [user1, user2, user3] = await Promise.all([\n      fetchUserData(1),\n      fetchUserData(2),\n      fetchUserData(3)\n    ]);\n    \n    console.log('All users:', { user1, user2, user3 });\n  } catch (error) {\n    console.error('One or more requests failed:', error);\n  }\n}\n\n// Promise.allSettled - handles both success and failure\nasync function getAllUsersWithErrors() {\n  const results = await Promise.allSettled([\n    fetchUserData(1),\n    fetchUserData(-1), // This will fail\n    fetchUserData(3)\n  ]);\n  \n  results.forEach((result, index) => {\n    if (result.status === 'fulfilled') {\n      console.log(`User ${index + 1}:`, result.value);\n    } else {\n      console.error(`User ${index + 1} failed:`, result.reason.message);\n    }\n  });\n}\n\n// Real-world example: API with retry logic\nasync function fetchWithRetry(url, maxRetries = 3) {\n  for (let attempt = 1; attempt <= maxRetries; attempt++) {\n    try {\n      const response = await fetch(url);\n      if (!response.ok) {\n        throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n      }\n      return await response.json();\n    } catch (error) {\n      console.log(`Attempt ${attempt} failed:`, error.message);\n      \n      if (attempt === maxRetries) {\n        throw new Error(`Failed after ${maxRetries} attempts: ${error.message}`);\n      }\n      \n      // Wait before retrying (exponential backoff)\n      await new Promise(resolve => setTimeout(resolve, 1000 * attempt));\n    }\n  }\n}",
      "keyPoints": [
        "Promises handle asynchronous operations with resolve/reject",
        "async/await provides cleaner syntax than .then() chains",
        "Promise.all() runs operations in parallel",
        "Always use try/catch with async/await for error handling"
      ],
      "quiz": {
        "question": "What's the main advantage of async/await over .then()?",
        "options": ["It's faster", "It's more readable and easier to debug", "It uses less memory", "It's supported in older browsers"],
        "correctAnswer": 1,
        "explanation": "async/await provides more readable, synchronous-looking code that's easier to debug and understand compared to .then() chains."
      },
      "tags": ["promises", "async", "await", "asynchronous"],
      "isCompleted": false,
      "isBookmarked": false
    },
    {
      "id": "fetch-api",
      "title": "Fetch API: Modern HTTP Requests",
      "day": 18,
      "category": "Asynchronous",
      "difficulty": "intermediate",
      "estimatedTime": "5 min",
      "description": "Master the Fetch API for making HTTP requests in modern JavaScript applications.",
      "content": "## Fetch API: Modern HTTP Requests\n\n### **Why Fetch API?**\n- **Modern replacement**: For outdated XMLHttpRequest\n- **Promise-based**: Native async/await support built-in\n- **Cleaner syntax**: More readable and maintainable than XHR\n- **Powerful features**: Request/Response objects with rich APIs\n- **Streaming support**: Handle large responses efficiently\n- **Wide browser support**: Available in all modern browsers\n\n### **Basic Request Structure**\n- **URL parameter**: Endpoint to make request to\n- **Options object**: Configuration for request method, headers, body\n- **Returns Promise**: Resolves to Response object\n- **Chain methods**: Use then() or async/await for handling\n\n### **HTTP Methods Support**\n- **GET requests**: Default method for retrieving data\n- **POST requests**: Send data to server for creation\n- **PUT requests**: Update existing resources completely\n- **PATCH requests**: Partial updates to existing resources\n- **DELETE requests**: Remove resources from server\n- **HEAD requests**: Get headers without response body\n\n### **Request Configuration Options**\n- **Headers object**: Set Content-Type, Authorization, custom headers\n- **Request body**: JSON strings, FormData, Blob, or plain text\n- **Credentials**: Include cookies and authentication headers\n- **Mode**: Control CORS behavior (cors, no-cors, same-origin)\n- **Cache**: Control caching behavior for requests\n- **Redirect**: How to handle redirect responses\n\n### **Response Object Properties**\n- **response.ok**: Boolean indicating success (status 200-299)\n- **response.status**: HTTP status code number\n- **response.statusText**: HTTP status message string\n- **response.headers**: Headers object with response headers\n- **response.url**: Final URL after any redirects\n- **response.type**: Response type (basic, cors, error, opaque)\n\n### **Response Parsing Methods**\n- **response.json()**: Parse JSON response body\n- **response.text()**: Get response as plain text string\n- **response.blob()**: Get response as binary Blob object\n- **response.arrayBuffer()**: Get response as ArrayBuffer\n- **response.formData()**: Parse FormData response\n\n### **Error Handling Specifics**\n- **Network errors**: Fetch only rejects on network failures\n- **HTTP error status**: 404, 500 etc. don't cause rejection\n- **Always check response.ok**: Before processing response data\n- **Custom error handling**: Throw errors for non-ok responses\n- **Timeout handling**: Use AbortController for request timeouts\n\n### **Advanced Features**\n- **Request cancellation**: AbortController for canceling requests\n- **File uploads**: FormData for multipart form submissions\n- **Progress tracking**: Monitor upload/download progress\n- **Request interceptors**: Modify requests before sending\n- **Response caching**: Control browser caching behavior\n\n### **Best Practices**\n- **Always handle errors**: Check response.ok and catch network errors\n- **Set appropriate headers**: Especially Content-Type for POST/PUT\n- **Validate responses**: Check data structure before using\n- **Use async/await**: Cleaner than Promise chains\n- **Handle loading states**: Show user feedback during requests\n- **Implement retries**: For failed requests when appropriate",
      "contentDetails": "## Fetch API Complete Guide\n\n### **Why Fetch API?**\n- **Modern replacement**: For XMLHttpRequest\n- **Promise-based**: Native async/await support\n- **Cleaner syntax**: More readable than XHR\n- **Powerful features**: Request/Response objects, streaming\n- **Wide support**: Available in all modern browsers\n\n### **Basic Fetch Syntax**\n```javascript\nfetch(url, options)\n  .then(response => response.json())\n  .then(data => console.log(data))\n  .catch(error => console.error(error));\n```\n\n### **HTTP Methods**\n\n#### **GET Request** (Default)\n```javascript\nconst response = await fetch('/api/users');\nconst data = await response.json();\n```\n\n#### **POST Request**\n```javascript\nconst response = await fetch('/api/users', {\n  method: 'POST',\n  headers: {\n    'Content-Type': 'application/json'\n  },\n  body: JSON.stringify({ name: 'Alice', email: 'alice@example.com' })\n});\n```\n\n#### **PUT Request**\n```javascript\nconst response = await fetch(`/api/users/${id}`, {\n  method: 'PUT',\n  headers: { 'Content-Type': 'application/json' },\n  body: JSON.stringify(updatedData)\n});\n```\n\n#### **DELETE Request**\n```javascript\nconst response = await fetch(`/api/users/${id}`, {\n  method: 'DELETE'\n});\n```\n\n### **Request Options**\n\n#### **Headers**\n```javascript\nconst options = {\n  headers: {\n    'Content-Type': 'application/json',\n    'Authorization': 'Bearer token123',\n    'X-Custom-Header': 'value'\n  }\n};\n```\n\n#### **Request Body Types**\n- **JSON**: `JSON.stringify(object)`\n- **Form Data**: `new FormData()`\n- **URL Encoded**: `new URLSearchParams()`\n- **Text**: Plain string\n- **Blob/File**: For file uploads\n\n### **Response Handling**\n\n#### **Response Properties**\n- **`response.ok`**: True if status 200-299\n- **`response.status`**: HTTP status code\n- **`response.statusText`**: Status message\n- **`response.headers`**: Response headers\n- **`response.url`**: Final URL (after redirects)\n\n#### **Response Methods**\n- **`.json()`**: Parse JSON response\n- **`.text()`**: Get response as text\n- **`.blob()`**: Get response as Blob\n- **`.arrayBuffer()`**: Get response as ArrayBuffer\n- **`.formData()`**: Parse FormData response\n\n### **Error Handling**\n\n#### **Important**: Fetch doesn't reject on HTTP errors!\n```javascript\nconst response = await fetch('/api/data');\nif (!response.ok) {\n  throw new Error(`HTTP error! status: ${response.status}`);\n}\nconst data = await response.json();\n```\n\n#### **Network Errors**\n- **Fetch rejects only on**: Network errors, CORS issues\n- **Not on**: 404, 500, or other HTTP error status codes\n- **Always check**: `response.ok` before processing\n\n### **Advanced Features**\n\n#### **Request Timeout**\n```javascript\nconst controller = new AbortController();\nsetTimeout(() => controller.abort(), 5000);\n\nfetch('/api/data', {\n  signal: controller.signal\n});\n```\n\n#### **File Upload**\n```javascript\nconst formData = new FormData();\nformData.append('file', fileInput.files[0]);\nformData.append('description', 'My file');\n\nfetch('/api/upload', {\n  method: 'POST',\n  body: formData // Don't set Content-Type for FormData\n});\n```\n\n#### **Credentials**\n```javascript\nfetch('/api/data', {\n  credentials: 'include' // Send cookies\n});\n```\n\n### **Best Practices**\n- **Always check `response.ok`**: Before processing data\n- **Handle network errors**: Use try/catch\n- **Set appropriate headers**: Especially Content-Type\n- **Use AbortController**: For request cancellation\n- **Don't set Content-Type**: For FormData uploads\n- **Validate responses**: Check data structure before using",
      "codeExample": "// Basic GET request\nasync function getUsers() {\n  try {\n    const response = await fetch('https://jsonplaceholder.typicode.com/users');\n    \n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n    \n    const users = await response.json();\n    console.log('Users:', users);\n    return users;\n  } catch (error) {\n    console.error('Fetch error:', error.message);\n  }\n}\n\n// POST request with JSON data\nasync function createUser(userData) {\n  try {\n    const response = await fetch('https://jsonplaceholder.typicode.com/users', {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'Authorization': 'Bearer your-token-here'\n      },\n      body: JSON.stringify(userData)\n    });\n    \n    if (!response.ok) {\n      throw new Error(`Failed to create user: ${response.status}`);\n    }\n    \n    const newUser = await response.json();\n    console.log('Created user:', newUser);\n    return newUser;\n  } catch (error) {\n    console.error('Create user error:', error.message);\n  }\n}\n\n// PUT request for updates\nasync function updateUser(userId, updates) {\n  const response = await fetch(`https://jsonplaceholder.typicode.com/users/${userId}`, {\n    method: 'PUT',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify(updates)\n  });\n  \n  return response.json();\n}\n\n// DELETE request\nasync function deleteUser(userId) {\n  const response = await fetch(`https://jsonplaceholder.typicode.com/users/${userId}`, {\n    method: 'DELETE'\n  });\n  \n  if (response.ok) {\n    console.log(`User ${userId} deleted successfully`);\n  }\n}\n\n// File upload with FormData\nasync function uploadFile(file) {\n  const formData = new FormData();\n  formData.append('file', file);\n  formData.append('description', 'User uploaded file');\n  \n  try {\n    const response = await fetch('/api/upload', {\n      method: 'POST',\n      body: formData // Don't set Content-Type header for FormData\n    });\n    \n    const result = await response.json();\n    console.log('Upload result:', result);\n  } catch (error) {\n    console.error('Upload failed:', error);\n  }\n}\n\n// Advanced: Request with timeout\nfunction fetchWithTimeout(url, options = {}, timeout = 5000) {\n  return Promise.race([\n    fetch(url, options),\n    new Promise((_, reject) => \n      setTimeout(() => reject(new Error('Request timeout')), timeout)\n    )\n  ]);\n}\n\n// Usage with error handling and loading states\nasync function handleApiCall() {\n  const loadingElement = document.querySelector('#loading');\n  const errorElement = document.querySelector('#error');\n  \n  try {\n    loadingElement.style.display = 'block';\n    errorElement.style.display = 'none';\n    \n    const data = await fetchWithTimeout('/api/data', {}, 3000);\n    const result = await data.json();\n    \n    // Update UI with data\n    console.log('Success:', result);\n  } catch (error) {\n    errorElement.textContent = error.message;\n    errorElement.style.display = 'block';\n  } finally {\n    loadingElement.style.display = 'none';\n  }\n}",
      "keyPoints": [
        "Always check response.ok before processing data",
        "Use appropriate HTTP methods (GET, POST, PUT, DELETE)",
        "Set correct headers, especially Content-Type for JSON",
        "Handle errors gracefully with try/catch blocks"
      ],
      "quiz": {
        "question": "What does response.ok check in the Fetch API?",
        "options": ["If the response has data", "If the status code is 200-299", "If the request was sent", "If the JSON is valid"],
        "correctAnswer": 1,
        "explanation": "response.ok returns true if the HTTP status code is in the 200-299 range, indicating a successful response."
      },
      "tags": ["fetch", "http", "api", "requests"],
      "isCompleted": false,
      "isBookmarked": false
    }
  ]
}
